<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js&#x2F;mutex.js - Mutex</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.4.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.4.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1><img src="..&#x2F;assets/css/logo.png"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: undefined</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Mutex.html">Mutex</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/gallery-mutex.html">gallery-mutex</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
    </div>


            <div class="apidocs">
                <div id="docs-main" class="content">
                    <h1 class="file-heading">File: js&#x2F;mutex.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * @module gallery-mutex
 *&#x2F;
(function (Y) {
    &#x27;use strict&#x27;;
    
    var _string_exclusive = &#x27;exclusive&#x27;,
        _string_shared = &#x27;shared&#x27;,
        
        &#x2F;**
         * Most people believe that Since JavaScript does not provide a
         * multi-threaded shared memory environment, JavaScript is completely
         * free from concurrency issues.  This is true at a low level;
         * JavaScript developers don&#x27;t need to worry about race conditions
         * between multiple processes or threads writing to the same memory
         * location.  At a higher level, asynchronous operations still allow for
         * similar problems to occur.
         * 
         * Imagine a function that does the following:
         * &lt;ol&gt;
         *     &lt;li&gt;
         *         Check the value of a variable.
         *     &lt;&#x2F;li&gt;
         *     &lt;li&gt;
         *         If the value is undefined, make a request to a server, receive
         *         data, set  the value of the variable.
         *     &lt;&#x2F;li&gt;
         *     &lt;li&gt;
         *         Pass the variable to a callback function.
         *     &lt;&#x2F;li&gt;
         * &lt;&#x2F;ol&gt;
         * 
         * It seems common for web applications to lazy load data like this as
         * needed.  Now imagine that there are several separate modules within a
         * web application which all require this data.  It&#x27;s possible for the
         * first module to call this function, the function sees that the value
         * is undefined, and sends a request to a server.  Then before the
         * request returns, the second module calls this function, the function
         * sees that the value is undefined and sends a request to a server.
         * Then before both of those requests return, the third module calls
         * this function, the function sees that the values is undefined and
         * sends a request to a server.  In this case, three requests are made
         * to a server for the same data.
         * 
         * It would be far better if the second and third calls to the function
         * just waited for the first request to complete.  Y.Mutex makes it
         * easier to accomplish this functionality.
         * 
         * Y.Mutex provides a concept of locking a resource.  Once an exclusive
         * resource lock is obtained, other parts of an application which
         * attempt to access the same resource, will have to wait until that
         * resource is unlocked.
         * 
         * The function above could be rewritten as follows:
         * &lt;ol&gt;
         *     &lt;li&gt;
         *         Obtain an exclusive lock for a variable.
         *     &lt;&#x2F;li&gt;
         *     &lt;li&gt;
         *         Check the value of a variable.
         *     &lt;&#x2F;li&gt;
         *     &lt;li&gt;
         *         If the value is undefined, make a request to a server,
         *         receive data, set the value of the variable.
         *     &lt;&#x2F;li&gt;
         *     &lt;li&gt;
         *         Unlock the variable.
         *     &lt;&#x2F;li&gt;
         *     &lt;li&gt;
         *         Pass the variable to a callback function.
         *     &lt;&#x2F;li&gt;
         * &lt;&#x2F;ol&gt;
         * 
         * This way, second or third or more calls to the function, before the
         * first request is complete, will always wait for the request to
         * complete instead of sending multiple unnecessary requests.
         * 
         * Just like locking in multi threaded applications, there are
         * disadvantages and dangers to locking.  There is a small amount of
         * overhead added to every resource access, even when the chances for
         * concurrency issues are very small.  Once a lock is obtained, it must
         * be unlocked; so error handling and time outs are important to ensure
         * that the entire application doesn&#x27;t break when something goes wrong.
         * It is possible to cause a deadlock when locking multiple resources at
         * once.
         * 
         * One advantage Y.Mutex has in JavaScript over other multi threaded
         * applications, the locks are asynchronous.  The application is not
         * blocked while waiting to acquire a lock.  Even if a deadlock occurs,
         * other parts of the application are not affected.  Y.Mutex also
         * provides multiple ways to cancel a particular lock, so there are
         * extra possibilities to recover from locking errors.
         * 
         * Y.Mutex offers exclusive locks and shared locks.  When a resource is
         * locked by an exclusive lock, Y.Mutex guarantees that no other locks
         * will be granted for the resource until the resource is unlocked.
         * When a resource is locked by a shared lock, Y.Mutex allows the
         * resource to be locked by multiple other shared locks at the same
         * time.  When a resource is locked by multiple shared locks, an
         * exclusive lock can not be obtained until all of the shared locks have
         * been unlocked.  Shared locks are generally used when just reading
         * values.  Exclusive locks are generally used when reading and writing
         * values.
         * 
         * Y.Mutex provides a way to deal with asynchronous concurrency issues,
         * but it does not prevent them.  If code from part of an application
         * uses Y.Mutex to lock a resource, there is nothing stopping code from
         * another part of the application from ignoring the lock and accessing
         * the resource directly.
         * @class Mutex
         * @static
         *&#x2F;
        _Mutex = Y.namespace(&#x27;Mutex&#x27;),
        
        _indexOf = Y.Array.indexOf,
        _isArray = Y.Lang.isArray,
        _later = Y.later,
        _soon = Y.soon;
        
    Y.mix(_Mutex, {
        &#x2F;**
         * Obtains an exclusive lock on a resource.
         * @method exclusive
         * @param {String} resourceName The name of the resource to lock.
         * @param {Function} callbackFunction The function that gets called when
         * the lock is obtained.  It is guaranteed not to be called
         * synchronously.  It is guaranteed not to be called more than once.  It
         * is not guaranteed to ever be called.  The callback function is passed
         * one argument, the unlock function which must be called to release the
         * lock.
         * @param {Number} timeout Optional.  The Approximate time in
         * milliseconds to wait after the callback function has been called.
         * Once the timeout has expired, if the callback function hasn&#x27;t yet
         * called the unlock function, the lock will be automatically released.
         * This does not halt, stop, or prevent anything that the callback
         * function might still be doing asynchronously; it just releases the
         * lock.  Using timeout is one way to reduce the possibility of
         * deadlocks, but it comes with the risk of allowing concurrent access
         * to the resource.
         * @return {Object} cancelObject An object with a cancel method.  When
         * the cancel method is called, if the callback function hasn&#x27;t yet
         * called the unlock function, the lock will be automatically released.
         * This does not halt, stop, or prevent anything that the callback
         * function might still be doing asynchronously; it just releases the
         * lock.  Using the cancel method is one way to reduce the possibiliy of
         * deadlocks, but it comes with the risk of allowing concurrent access
         * to the resource.  The cancelObject also has a mode property.
         * @static
         *&#x2F;
        exclusive: function (resourceName, callbackFunction, timeout) {
            return _Mutex._queue(_string_exclusive, resourceName, callbackFunction, timeout);
        },
        &#x2F;**
         * Obtains an shared lock on a resource.
         * @method exclusive
         * @param {String} resourceName The name of the resource to lock.
         * @param {Function} callbackFunction The function that gets called when
         * the lock is obtained.  It is guaranteed not to be called
         * synchronously.  It is guaranteed not to be called more than once.  It
         * is not guaranteed to ever be called.  The callback function is passed
         * one argument, the unlock function which must be called to release the
         * lock.
         * @param {Number} timeout Optional.  The Approximate time in
         * milliseconds to wait after the callback function has been called.
         * Once the timeout has expired, if the callback function hasn&#x27;t yet
         * called the unlock function, the lock will be automatically released.
         * This does not halt, stop, or prevent anything that the callback
         * function might still be doing asynchronously; it just releases the
         * lock.  Using timeout is one way to reduce the possibility of
         * deadlocks, but it comes with the risk of allowing concurrent access
         * to the resource.
         * @return {Object} cancelObject An object with a cancel method.  When
         * the cancel method is called, if the callback function hasn&#x27;t yet
         * called the unlock function, the lock will be automatically released.
         * This does not halt, stop, or prevent anything that the callback
         * function might still be doing asynchronously; it just releases the
         * lock.  Using the cancel method is one way to reduce the possibiliy of
         * deadlocks, but it comes with the risk of allowing concurrent access
         * to the resource.  The cancelObject also has a mode property.
         * @static
         *&#x2F;
        shared: function (resourceName, callbackFunction, timeout) {
            return _Mutex._queue(_string_shared, resourceName, callbackFunction, timeout);
        },
        &#x2F;**
         * Immediately grants a lock on a resource.
         * @method _lock
         * @param {String} mode Either &#x27;exclusive&#x27; or &#x27;shared&#x27;.
         * @param {String} guid The lock&#x27;s internal id.
         * @param {String} resourceName The name of the resource to lock.
         * @param {Function} callbackFunction The function that gets called when
         * the lock is obtained.  It is guaranteed not to be called
         * synchronously.  It is guaranteed not to be called more than once.  It
         * is not guaranteed to ever be called.  The callback function is passed
         * one argument, the unlock function which must be called to release the
         * lock.
         * @param {Number} timeout Optional.  The Approximate time in
         * milliseconds to wait after the callback function has been called.
         * Once the timeout has expired, if the callback function hasn&#x27;t yet
         * called the unlock function, the lock will be automatically released.
         * This does not halt, stop, or prevent anything that the callback
         * function might still be doing asynchronously; it just releases the
         * lock.  Using timeout is one way to reduce the possibility of
         * deadlocks, but it comes with the risk of allowing concurrent access
         * to the resource.
         * @protected
         * @return {Object} timerObject An object that will asynchronously later
         * be given a timer property.
         * @static
         *&#x2F;
        _lock: function (mode, guid, resourceName, callbackFunction, timeout) {
            var lock = _Mutex._locks[resourceName],
                timerWrapper = {};
            
            if (mode === _string_exclusive) {
                lock.l = guid;
            } else if (mode === _string_shared) {
                (function (lockArray) {
                    if (!Y.Lang.isArray(lockArray)) {
                        lockArray = [];
                        lock.l = lockArray;
                    }
                    
                    lockArray.push(guid);
                }(lock.l));
            } else {
                return timerWrapper;
            }

            _soon(function () {
                var timer;
                
                if (timeout) {
                    timer = _later(timeout, _Mutex, _Mutex._unlock, [
                        guid,
                        mode,
                        resourceName
                    ]);
                    timerWrapper.timer = timer;
                }
                
                callbackFunction(function () {
                    _Mutex._unlock(guid, mode, resourceName, timer);
                });
            });
            
            return timerWrapper;
        },
        &#x2F;**
         * An object containing the state of currently held and queued locks.
         * @property _locks
         * @protected
         * @static
         *&#x2F;
        _locks: {},
        &#x2F;**
         * Wait in queue to obtain a lock on a resource.
         * @method _queue
         * @param {String} mode Either &#x27;exclusive&#x27; or &#x27;shared&#x27;.
         * @param {String} resourceName The name of the resource to lock.
         * @param {Function} callbackFunction The function that gets called when
         * the lock is obtained.  It is guaranteed not to be called
         * synchronously.  It is guaranteed not to be called more than once.  It
         * is not guaranteed to ever be called.  The callback function is passed
         * one argument, the unlock function which must be called to release the
         * lock.
         * @param {Number} timeout Optional.  The Approximate time in
         * milliseconds to wait after the callback function has been called.
         * Once the timeout has expired, if the callback function hasn&#x27;t yet
         * called the unlock function, the lock will be automatically released.
         * This does not halt, stop, or prevent anything that the callback
         * function might still be doing asynchronously; it just releases the
         * lock.  Using timeout is one way to reduce the possibility of
         * deadlocks, but it comes with the risk of allowing concurrent access
         * to the resource.
         * @protected
         * @return {Object} cancelObject An object with a cancel method.  When
         * the cancel method is called, if the callback function hasn&#x27;t yet
         * called the unlock function, the lock will be automatically released.
         * This does not halt, stop, or prevent anything that the callback
         * function might still be doing asynchronously; it just releases the
         * lock.  Using the cancel method is one way to reduce the possibiliy of
         * deadlocks, but it comes with the risk of allowing concurrent access
         * to the resource.  The cancelObject also has mode property.
         * @static
         *&#x2F;
        _queue: function (mode, resourceName, callbackFunction, timeout) {
            var _locks = _Mutex._locks,
                
                guid = Y.guid(mode),
                lock = _locks[resourceName],
                queue,
                queueDetails = [
                    mode,
                    guid,
                    resourceName,
                    callbackFunction,
                    timeout
                ],
                timerWrapper;

            if (!lock) {
                lock = {};
                _locks[resourceName] = lock;
            }

            if (lock.l &amp;&amp; (mode === _string_exclusive || !_isArray(lock.l))) {
                queue = lock.q;

                if (!queue) {
                    queue = [];
                    lock.q = queue;
                }

                queue.push(queueDetails);
            } else {
                timerWrapper = _Mutex._lock.apply(_Mutex, queueDetails);
            }

            return {
                cancel: function () {
                    _Mutex._unlock(guid, mode, resourceName, timerWrapper &amp;&amp; timerWrapper.timer);
                },
                mode: mode
            };
        },
        &#x2F;**
         * Unlocks a currently held lock on a resource and processes the next
         * lock in queue as needed.
         * @method _unlock
         * @param {String} guid The lock&#x27;s internal id.  If this is not the id
         * of a lock currently held on this resource, this method will do
         * nothing.
         * @param {String} mode Either &#x27;exclusive&#x27; or &#x27;shared&#x27;.
         * @param {String} resourceName The name of the locked resource.
         * @param {Object} timer Optional.  The lock&#x27;s timout timer to cancel.
         * @protected
         * @static
         *&#x2F;
        _unlock: function (guid, mode, resourceName, timer) {
            var _locks = _Mutex._locks,
                
                lock = _locks[resourceName],
                locked = lock &amp;&amp; lock.l,
                queue = lock &amp;&amp; lock.q,
                queueDetails;

            if (timer) {
                timer.cancel();
            }

            if (!lock || mode === _string_exclusive &amp;&amp; locked !== guid) {
                return;
            }
            
            if (mode === _string_shared &amp;&amp; !(function (index) {
                if (index === -1) {
                    return false;
                }
                
                var after = locked.slice(index + 1);
                locked.length = index;
                locked.push.apply(locked, after);
                
                return !locked.length;
            }(_isArray(locked) ? _indexOf(locked, guid) : -1))) {
                return;
            }

            if (queue &amp;&amp; queue.length) {
                do {
                    queueDetails = queue.shift();
                    _Mutex._lock.apply(_Mutex, queueDetails);
                } while (queueDetails[0] === _string_shared &amp;&amp; queue[0] &amp;&amp; queue[0][0] === _string_shared);
            } else {
                delete _locks[resourceName];
            }
        }
    });
}(Y));
    </pre>
</div>

                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<!--script src="..&#x2F;assets/js/tabs.js"></script-->
<script src="..&#x2F;assets/../api.js"></script>


<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
